# Alexis Dionne
# Compiler Project 2 - Parser
# 3/6/19

from Token import Token
from Tree import Tree

class Parser:

  # the parser will determine if the program makes sense with movements of the grammar
  
  def __init__(self, tokenList=[], programNumber=0):
    self.tokenList = tokenList          # the list of tokens generated by Lex
    self.tracker = 0                    # the current index position of currentToken in the tokenList
    self.currentToken = tokenList[0]    # the token we are currently trying to match
    self.nextToken = tokenList[1]       # one token look ahead
    self.tree = Tree()                  # the tree the CST will be built in
    self.errors = 0
    self.programNumber = programNumber  # purely for printing nice
    
    # FIRST sets that have more than one option
    self.FIRST = {
      "OfStatement" : ['P_STMT', 'ID', 'TYPE', 'W_STMT', 'I_STMT', 'L_BRACE'],
      "OfBooleanExpr" : ['L_PAREN', 'B_VAL']
    }
    # a list of terminals in the grammar used in matching with FIRST sets
    self.terminals = {
      "CHAR" : ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],
      "DIGIT" : ['0','1','2','3','4','5','6','7','8','9'],
      "TYPE" : ['int', 'string', 'boolean'],
      "SPACE" : [' '],
      "BOOLOP" : ['==', '!='],
      "B_VAL" : ['false', 'true'],
      "INTOP" : ['+'],
      "W_STMT" : ['while'],
      "P_STMT" : ['print'],
      "I_STMT" : ['if'],
      "A_STMT" : ['='],
      "L_BRACE" : ['{'],
      "R_BRACE" : ['}'],
      "L_PAREN" : ['('],
      "R_PAREN" : [')'],
      "EoP" : ['$'],
      "QUOTE" : ['"']
    }
    
  def matchAndConsume(self, expectedTokens):
    # determine if the current token is a fit with expected set and consume if it is
    if self.currentToken.value in expectedTokens:
      self.tree.addNode(self.currentToken.value, "leaf")
      self.tracker += 1
      # prevent going out of bounds
      if self.tracker < len(self.tokenList):
        self.currentToken = self.tokenList[self.tracker]
    else:
      # report an error because our next movement is bupkis
      print("Parser ERROR - Found [",self.currentToken.value,"] on line",self.currentToken.lineNumber," : Expected ",expectedTokens)
      self.errors += 1
      
    
  def parseProgram(self):
    # every program starts with the program node
    print("Parsing Program()")
    self.tree.addNode("Program", "branch")
    self.parseBlock()
    self.matchAndConsume(self.terminals["EoP"])
    if self.errors is 0:
      print("Parse Succeeded with no errors")
      # print CST because parse succeeded
      print("\nCST of Program",self.programNumber,"...")
      print(self.tree.toString())
    else:
      # can't move on anywhere or print because this program made no sense
      print("Parse failed with",self.errors,"error(s)")
    
    
  def parseBlock(self):
    print("Parsing Block()")
    self.tree.addNode("Block", "branch")
    self.matchAndConsume(self.terminals["L_BRACE"])
    self.parseStatementList()
    self.matchAndConsume(self.terminals["R_BRACE"])
    self.tree.returnToParent()
    
    
  def parseStatementList(self):
    print("Parsing Statement List()")
    self.tree.addNode("Statement List", "branch")
    # only move in if the currentToken is in the FIRST set of Statement
    if self.currentToken.type in self.FIRST["OfStatement"]:
      self.parseStatement()
      self.parseStatementList()
  # else:  epsilon production - nothing happens
    self.tree.returnToParent()
  
  
  def parseStatement(self):
    print("Parsing Statement()")
    self.tree.addNode("Statement", "branch")
    # determine which terminal matches the currentToken
    if self.currentToken.type is 'P_STMT':
      self.parsePrint()
    elif self.currentToken.type is 'ID':
      self.parseAssignment()
    elif self.currentToken.type is 'TYPE':
      self.parseVarDecl()
    elif self.currentToken.type is 'W_STMT':
      self.parseWhile()
    elif self.currentToken.type is 'I_STMT':
      self.parseIf()
    elif self.currentToken.type is 'L_BRACE':
      self.parseBlock()
    self.tree.returnToParent()
      
      
  def parsePrint(self):
    print("Parsing Print()")
    self.tree.addNode("Print", "branch")
    self.matchAndConsume(self.terminals["P_STMT"])
    self.matchAndConsume(self.terminals["L_PAREN"])
    self.parseExpr()
    self.matchAndConsume(self.terminals["R_PAREN"])
    self.tree.returnToParent()
  
  
  def parseAssignment(self):
    print("Parsing Assignment()")
    self.tree.addNode("Assignment", "branch")
    self.parseId()
    self.matchAndConsume(self.terminals["A_STMT"])
    self.parseExpr()
    self.tree.returnToParent()
  
  
  def parseVarDecl(self):
    print("Parsing VarDecl()")
    self.tree.addNode("VarDecl", "branch")
    self.matchAndConsume(self.terminals["TYPE"])
    self.parseId()
    self.tree.returnToParent()
  
  
  def parseWhile(self):
    print("Parsing While()")
    self.tree.addNode("While", "branch")
    self.matchAndConsume(self.terminals["W_STMT"])
    self.parseBooleanExpr()
    self.parseBlock()
    self.tree.returnToParent()
  
  
  def parseIf(self):
    print("Parsing If()")
    self.tree.addNode("If", "branch")
    self.matchAndConsume(self.terminals["I_STMT"])
    self.parseBooleanExpr()
    self.parseBlock()
    self.tree.returnToParent()
    
    
  def parseExpr(self):
    print("Parsing Expr()")
    self.tree.addNode("Expr", "branch")
    # determine which of the terminals match the currentToken
    if self.currentToken.type is 'DIGIT':
      self.parseIntExpr()
    elif self.currentToken.type is 'QUOTE':
      self.parseStringExpr()
    elif self.currentToken.type in self.FIRST["OfBooleanExpr"]:
      self.parseBooleanExpr()
    elif self.currentToken.type is 'ID':
      self.parseId()
    self.tree.returnToParent()
      
      
  def parseIntExpr(self):
    print("Parsing IntExpr()")
    self.tree.addNode("IntExpr", "branch")
    # consome a digit regardless because it has to start with one or be one
    self.matchAndConsume(self.terminals["DIGIT"])
    if self.currentToken.type is "INTOP":
      self.matchAndConsume(self.terminals["INTOP"])
      self.parseExpr()
  # else: Do nothing. Epsilon production
    self.tree.returnToParent()
      
      
  def parseStringExpr(self):
    print("Parsing StringExpr()")
    self.tree.addNode("String", "branch")
    self.matchAndConsume(self.terminals["QUOTE"])
    self.parseCharList()
    self.matchAndConsume(self.terminals["QUOTE"])
    self.tree.returnToParent()
    
    
  def parseBooleanExpr(self):
    print("Parsing BooleanExpr()")
    self.tree.addNode("BooleanExpr", "branch")
    # determine which of the terminals match the currentToken
    if self.currentToken.type is "L_PAREN":
      # expand to a comparison
      self.matchAndConsume(self.terminals["L_PAREN"])
      self.parseExpr()
      self.matchAndConsume(self.terminals["BOOLOP"])
      self.parseExpr()
      self.matchAndConsume(self.terminals["R_PAREN"])
    else:
      # consume a true or false
      self.matchAndConsume(self.terminals["B_VAL"])
    self.tree.returnToParent()
  
  
  def parseId(self):
    print("Parsing Id()")
    self.tree.addNode("Id", "branch")
    self.matchAndConsume(self.terminals["CHAR"])
    self.tree.returnToParent()
    
    
  def parseCharList(self):
    print("Parsing CharList()")
    self.tree.addNode("CharList", "branch")
    # determine if the currentToken is a space or character
    if self.currentToken.type is "CHAR":
      self.matchAndConsume(self.terminals["CHAR"])
      self.parseCharList()
    elif self.currentToken.type is "SPACE":
      self.matchAndConsume(self.terminals["SPACE"])
      self.parseCharList()
  # else:  epsilon production. Do nothing.
    self.tree.returnToParent()