# Alexis Dionne
# Compiler Project 2 - Parser
# 3/6/19

from Token import Token
from Tree import Tree

class Parser:

  # the parser will determine if the program makes sense with the grammar
  
  def __init__(self, tokenList=[], programNumber=0):
    self.tokenList = tokenList  # the list of tokens generated by Lex
    self.tracker = 0  # the current index position of currentToken in the tokenList
    self.currentToken = tokenList[0]    # the token we are currently trying to match
    self.nextToken = tokenList[1]       # one token look ahead
    self.tree = Tree()
    self.errors = 0
    self.programNumber = programNumber
    
    self.FIRST = {
      "OfStatement" : ['P_STMT', 'ID', 'TYPE', 'W_STMT', 'I_STMT', 'L_BRACE'],
      "OfBooleanExpr" : ['L_PAREN', 'B_VAL']
    }
    self.terminals = {
      "CHAR" : ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],
      "DIGIT" : ['0','1','2','3','4','5','6','7','8','9'],
      "TYPE" : ['int', 'string', 'boolean'],
      "SPACE" : [' '],
      "BOOLOP" : ['==', '!='],
      "B_VAL" : ['false', 'true'],
      "INTOP" : ['+'],
      "W_STMT" : ['while'],
      "P_STMT" : ['print'],
      "I_STMT" : ['if'],
      "A_STMT" : ['='],
      "L_BRACE" : ['{'],
      "R_BRACE" : ['}'],
      "L_PAREN" : ['('],
      "R_PAREN" : [')'],
      "EoP" : ['$'],
      "QUOTE" : ['"']
    }
    
  def matchAndConsume(self, expectedTokens):
    # determine if the current token is a fit
    # and then move on if it is
    #print("current token type is ",self.currentToken.type)
    #print("expected:",expectedTokens)
    if self.currentToken.value in expectedTokens:
      #print("added leaf for currentToken: ",self.currentToken.value)
      self.tree.addNode(self.currentToken.value, "leaf")
      self.tracker += 1
      if self.tracker < len(self.tokenList):
        self.currentToken = self.tokenList[self.tracker]
        #print("ACCEPTED: parent of", self.tree.current.name,"is",self.tree.current.parent.name)
        if self.tracker < len(self.tokenList) - 1:
          self.nextToken = self.tokenList[self.tracker + 1]
      #else:
        #print("end of token stream")
        #print("ROOT ?? ", self.tree.current.name)
    else:
      # report an error because our next movement is bupkis
      #print(" !!! whoops, thats not what we expected")
      #print("found a :", self.currentToken.value)
      print("ERROR: Found a",self.currentToken.value," : Expected",expectedTokens)
      self.errors += 1
      # what does dispose of tree mean?
    #self.tree.returnToParent()
    #print("        CURRENT NODE: ", self.tree.current.name,"\n")#,"is",self.tree.current.parent.name)
    
    
  def parseProgram(self):
    print("Parsing Program()")
    self.tree.addNode("Program", "branch")
    self.parseBlock()
    self.matchAndConsume(self.terminals["EoP"])
    if self.errors is 0:
      print("\nCST of Program",self.programNumber,"...")
      print(self.tree.toString())
    print("ERROR COUNT:",self.errors)
    
    
  def parseBlock(self):
    print("Parsing Block()")
    self.tree.addNode("Block", "branch")
    self.matchAndConsume(self.terminals["L_BRACE"])
    self.parseStatementList()
    self.matchAndConsume(self.terminals["R_BRACE"])
    self.tree.returnToParent()
    
    
  def parseStatementList(self):
    print("Parsing Statement List()")
    self.tree.addNode("Statement List", "branch")
    if self.currentToken.type in self.FIRST["OfStatement"]:
      self.parseStatement()
      self.parseStatementList()
    #else:  epsilon production - nothing happens
      #print("stmtlist epsilon")
    self.tree.returnToParent()
  
  
  def parseStatement(self):
    print("Parsing Statement()")
    self.tree.addNode("Statement", "branch")
    if self.currentToken.type is 'P_STMT':
      self.parsePrint()
    elif self.currentToken.type is 'ID':
      self.parseAssignment()
    elif self.currentToken.type is 'TYPE':
      self.parseVarDecl()
    elif self.currentToken.type is 'W_STMT':
      self.parseWhile()
    elif self.currentToken.type is 'I_STMT':
      self.parseIf()
    elif self.currentToken.type is 'L_BRACE':
      self.parseBlock()
    self.tree.returnToParent()
      
      
  def parsePrint(self):
    print("Parsing Print()")
    self.tree.addNode("Print", "branch")
    self.matchAndConsume(self.terminals["P_STMT"])
    self.matchAndConsume(self.terminals["L_PAREN"])
    self.parseExpr()
    self.matchAndConsume(self.terminals["R_PAREN"])
    self.tree.returnToParent()
  
  
  def parseAssignment(self):
    print("Parsing Assignment()")
    self.tree.addNode("Assignment", "branch")
    self.parseId()
    self.matchAndConsume(self.terminals["A_STMT"])
    self.parseExpr()
    self.tree.returnToParent()
  
  
  def parseVarDecl(self):
    print("Parsing VarDecl()")
    self.tree.addNode("VarDecl", "branch")
    self.matchAndConsume(self.terminals["TYPE"]) # not the real thing, just a place holder
    self.parseId()
    self.tree.returnToParent()
  
  
  def parseWhile(self):
    print("Parsing While()")
    self.tree.addNode("While", "branch")
    self.matchAndConsume(self.terminals["W_STMT"])
    self.parseBooleanExpr()
    self.parseBlock()
    self.tree.returnToParent()
  
  
  def parseIf(self):
    print("Parsing If()")
    self.tree.addNode("If", "branch")
    self.matchAndConsume(self.terminals["I_STMT"])
    self.parseBooleanExpr()
    self.parseBlock()
    self.tree.returnToParent()
    
    
  def parseExpr(self):
    print("Parsing Expr()")
    self.tree.addNode("Expr", "branch")
    if self.currentToken.type is 'DIGIT':
      self.parseIntExpr()
    elif self.currentToken.type is 'QUOTE':
      self.parseStringExpr()
    elif self.currentToken.type in self.FIRST["OfBooleanExpr"]:
      self.parseBooleanExpr()
    elif self.currentToken.type is 'ID':
      self.parseId()
    self.tree.returnToParent()
      
      
  def parseIntExpr(self):
    print("Parsing IntExpr...")
    self.tree.addNode("IntExpr", "branch")
    self.matchAndConsume(self.terminals["DIGIT"])
    if self.currentToken.type is "INTOP":
      self.matchAndConsume(self.terminals["INTOP"])
      self.parseExpr()
    #else: Do nothing. Epsilon production
      #print("intexpr epsilon")
    self.tree.returnToParent()
      
      
  def parseStringExpr(self):
    print("Parsing StringExpr()")
    self.tree.addNode("String", "branch")
    self.matchAndConsume(self.terminals["QUOTE"])
    self.parseCharList()
    self.matchAndConsume(self.terminals["QUOTE"])
    self.tree.returnToParent()
    
    
  def parseBooleanExpr(self):
    print("Parsing BooleanExpr()")
    self.tree.addNode("BooleanExpr", "branch")
    if self.currentToken.type is "L_PAREN":
      self.matchAndConsume(self.terminals["L_PAREN"])
      self.parseExpr()
      self.matchAndConsume(self.terminals["BOOLOP"])
      self.parseExpr()
      self.matchAndConsume(self.terminals["R_PAREN"])
    else:
      self.matchAndConsume(self.terminals["B_VAL"])
    self.tree.returnToParent()
  
  
  def parseId(self):
    print("Parsing Id...")
    self.tree.addNode("Id", "branch")
    self.matchAndConsume(self.terminals["CHAR"])
    self.tree.returnToParent()
    
    
  def parseCharList(self):
    print("Parsing CharList()")
    self.tree.addNode("CharList", "branch")
    if self.currentToken.type is "CHAR":
      self.matchAndConsume(self.terminals["CHAR"])
      self.parseCharList()
    elif self.currentToken.type is "SPACE":
      self.matchAndConsume(self.terminals["SPACE"])
      self.parseCharList()
    #else:
      # epsilon production
      #print("charlist epsilon")
    self.tree.returnToParent()