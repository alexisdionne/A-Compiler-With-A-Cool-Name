# Alexis Dionne
# Compiler Project 2 - Parser
# 3/6/19

from Token import Token
from Tree import Tree

class Parser:

  # the parser will determine if the program makes sense with the grammar
  
  def __init__(self, tokenList=[]):
    self.tokenList = tokenList  # the list of tokens generated by Lex
    self.currentToken = None    # the token we are currently trying to match
    self.nextToken = None       # one token look ahead
    self.tree = Tree()
    
    self.FIRST = {
      "OfStatement" : [
    
  def matchAndConsume(expectedTokens):
    if self.currentToken in expectedTokens:
      self.tree.addNode(self.currentToken.name, "leaf")
    
  def parseProgram():
    print("Parsing Program ...")
    self.tree.addNode("Program", "branch")
    parseBlock()
    matchAndConsume("$")
    
  def parseBlock():
    print("Parsing Block...")
    self.tree.addNode("Block", "branch")
    matchAndConsume("{")
    parseStatementList()
    matchAndConsume("}")
    self.tree.returnToParent()
    
  def parseStatementList():
print("Parsing Statement List...")
    self.tree.addNode("Statement List", "branch")
    if self.currentToken in self.FIRST["OfStatement"]:
      parseStatement()
      parseStatementList()
    else:
      # epsilon production - nothing happens
    self.tree.returnToParent()
  
  def parseStatement():
    print("Parsing Statement...")
    self.tree.addNode("Statement", "branch")
    if self.currentToken in firstOfPrint:
      parsePrint()
    elif self.currentToken in firstOfAssigment:
      parseAssignment()
    elif self.currentToken in firstOfVarDecl:
      parseVarDecl()
    elif self.currentToken in firstOfWhile:
      parseWhile()
    elif self.currentToken in firstOfIf:
      parseIf()
    elif self.currentToken in firstOfBlock:
      parseBlock()
    self.tree.returnToParent()
      
  def parsePrint():
    print("Parsing Print...")
    self.tree.addNode("Print", "branch")
    matchAndConsume(firstOfPrint)
    matchAndConsume("(")
    parseExpr()
    matchAndConsume(")")
    self.tree.returnToParent()
  
  def parseAssignment():
    print("Parsing Assignment ...")
    self.tree.addNode("Assignment", "branch")
    parseId()
    matchAndConsume("=")
    parseExpr()
    self.tree.returnToParent()
  
  def parseVarDecl():
    print("Parsing VarDecl ...")
    self.tree.addNode("VarDecl", "branch")
    matchAndConsume("TYPE") # not the real thing, just a place holder
    parseId()
    self.tree.returnToParent()
  
  def parseWhile():
    print("Parsing While ...")
    self.tree.addNode("While", "branch")
    matchAndConsume(firstOfWhile)
    parseBooleanExpr()
    parseBlock()
    self.tree.returnToParent()
  
  def parseIf():
    print("Parsing If ...")
    self.tree.addNode("If", "branch")
    matchAndConsume(firstOfIf)
    parseBooleanExpr()
    parseBlock()
    self.tree.returnToParent()
    
  def parseExpr():
    print("Parsing Expr ...")
    self.tree.addNode("Expr", "branch")
    if self.currentToken in firstOfIntExpr:
      parseIntExpr()
    elif self.currentToken in firstOfStringExpr:
      parseStringExpr()
    elif self.currentToken in firstOfBooleanExpr:
      parseBooleanExpr()
    elif self.currentToken in firstOfId:
      parseId()
    self.tree.returnToParent()
      
  def parseIntExpr():
    print("Parsing IntExpr...")
    self.tree.addNode("IntExpr", "branch")
    matchAndConsume(firstOfDigit)
    if self.nextToken is "+":
      matchAndConsume("+")
      parseExpr()
    else:
      # just the digit is consumed
    self.tree.returnToParent()
      
  def parseStringExpr():
    print("Parsing StringExpr ...")
    self.tree.addNode("String", "branch")
    matchAndConsume('"')
    parseCharList()
    matchAndConsume('"')
    self.tree.returnToParent()
    
  def parseBooleanExpr():
    print("Parsing BooleanExpr ...")
    self.tree.addNode("BooleanExpr", "branch")
    if self.currentToken is "(":
      matchAndConsume("(")
      parseExpr()
      matchAndConsume(firstOfBoolop) # also a place holder
      parseExpr()
      matchAndConsume(")")
    else:
      matchAndConsume(firstOfBoolVal) # place holderrr
    self.tree.returnToParent()
  
  def parseId():
    print("Parsing Id...")
    self.tree.addNode("Id", "branch")
    matchAndConsume(firstOfChar)
    self.tree.returnToParent()
    
  def parseCharList():
    print("Parsing CharList ...")
    self.tree.addNode("CharList", "branch")
    if self.currentToken in firstOfChar:
      matchAndConsume(firstOfChar)
      parseCharList()
    elif self.currentToken in firstOfSpace:
      matchAndConsume(firstOfSpace)
      parseCharList()
    else:
      # epsilon production
    self.tree.returnToParent()