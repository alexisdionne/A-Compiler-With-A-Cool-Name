# Alexis Dionne
# Compiler Project 2 - Parser
# 3/6/19

from Token import Token
from Tree import Tree

class Parser:

  # the parser will determine if the program makes sense with the grammar
  
  def __init__(self, tokenList=[]):
    self.tokenList = tokenList  # the list of tokens generated by Lex
    self.tracker = 0  # the current index position of currentToken in the tokenList
    self.currentToken = tokenList[0]    # the token we are currently trying to match
    self.nextToken = tokenList[1]       # one token look ahead
    self.tree = Tree()
    self.errors = 0
    
    self.FIRST = {
      "OfStatement" : ['P_STMT', 'CHAR', 'TYPE', 'W_STMT', 'I_STMT', 'L_BRACE'],
      "OfBooleanExpr" : ['L_BRACE', 'B_VAL']
    }
    self.terminals = {
      "CHAR" : ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],
      "DIGIT" : ['0','1','2','3','4','5','6','7','8','9'],
      "TYPE" : ['int', 'string', 'boolean'],
      "SPACE" : [' '],
      "BOOLOP" : ['==', '!='],
      "B_VAL" : ['false', 'true'],
      "INTOP" : ['+'],
      "W_STMT" : ['while'],
      "P_STMT" : ['print'],
      "I_STMT" : ['if'],
      "A_STMT" : ['='],
      "L_BRACE" : ['{'],
      "R_BRACE" : ['}'],
      "L_PAREN" : ['('],
      "R_PAREN" : [')']
    }
    
  def matchAndConsume(self, expectedTokens):
    # determine if the current token is a fit
    # and then move on if it is
    if self.currentToken.type in expectedTokens:
      print("added leaf for currentToken: ",self.currentToken.value)
      self.tree.addNode(self.currentToken.value, "leaf")
      self.tracker += 1
      if self.tracker < len(self.tokenList):
        self.currentToken = self.tokenList[self.tracker]
        if self.tracker < len(self.tokenList) - 1:
          self.nextToken = self.tokenList[self.tracker + 1]
      else:
        print("end of token stream")
    else:
      # report an error because our next movement is bupkis
      print("whoops, thats not what we expected")
      print("found a :", self.currentToken.value)
      self.errors += 1
      # what does dispose of tree mean?
    self.tree.returnToParent()
    
  def parseProgram(self):
    print("Parsing Program() ...")
    self.tree.addNode("Program", "branch")
    self.parseBlock()
    self.matchAndConsume("EoP")
    
  def parseBlock(self):
    print("Parsing Block() ...")
    self.tree.addNode("Block", "branch")
    self.matchAndConsume("L_BRACE")
    self.parseStatementList()
    self.matchAndConsume("R_BRACE")
    self.tree.returnToParent()
    
  def parseStatementList(self):
    print("Parsing Statement List() ...")
    self.tree.addNode("Statement List", "branch")
    if self.currentToken.type in self.FIRST["OfStatement"]:
      self.parseStatement()
      self.parseStatementList()
    else:
      # epsilon production - nothing happens
      print("stmtlist epsilon")
    self.tree.returnToParent()
  
  def parseStatement(self):
    print("Parsing Statement() ...")
    self.tree.addNode("Statement", "branch")
    if self.currentToken.type is 'P_STMT':
      self.parsePrint()
    elif self.currentToken.type is 'CHAR':
      self.parseAssignment()
    elif self.currentToken.type is 'TYPE':
      self.parseVarDecl()
    elif self.currentToken.type is 'W_STMT':
      self.parseWhile()
    elif self.currentToken.type is 'I_STMT':
      self.parseIf()
    elif self.currentToken.type is 'L_BRACE':
      self.parseBlock()
    self.tree.returnToParent()
      
  def parsePrint(self):
    print("Parsing Print() ...")
    self.tree.addNode("Print", "branch")
    self.matchAndConsume(self.terminals["P_STMT"])
    self.matchAndConsume("L_PAREN")
    self.parseExpr()
    self.matchAndConsume("R_PAREN")
    self.tree.returnToParent()
  
  def parseAssignment(self):
    print("Parsing Assignment() ...")
    self.tree.addNode("Assignment", "branch")
    self.parseId()
    self.matchAndConsume("A_STMT")
    self.parseExpr()
    self.tree.returnToParent()
  
  def parseVarDecl(self):
    print("Parsing VarDecl() ...")
    self.tree.addNode("VarDecl", "branch")
    self.matchAndConsume("TYPE") # not the real thing, just a place holder
    self.parseId()
    self.tree.returnToParent()
  
  def parseWhile(self):
    print("Parsing While() ...")
    self.tree.addNode("While", "branch")
    self.matchAndConsume(self.terminals["W_STMT"])
    self.parseBooleanExpr()
    self.parseBlock()
    self.tree.returnToParent()
  
  def parseIf(self):
    print("Parsing If() ...")
    self.tree.addNode("If", "branch")
    self.matchAndConsume("I_STMT")
    self.parseBooleanExpr()
    self.parseBlock()
    self.tree.returnToParent()
    
  def parseExpr(self):
    print("Parsing Expr() ...")
    self.tree.addNode("Expr", "branch")
    if self.currentToken.type is 'DIGIT':
      self.parseIntExpr()
    elif self.currentToken.type is 'QUOTE':
      self.parseStringExpr()
    elif self.currentToken.type in self.FIRST["OfBooleanExpr"]:
      self.parseBooleanExpr()
    elif self.currentToken.type is 'ID':
      self.parseId()
    self.tree.returnToParent()
      
  def parseIntExpr(self):
    print("Parsing IntExpr...")
    self.tree.addNode("IntExpr", "branch")
    self.matchAndConsume(self.terminals["DIGIT"])
    if self.nextToken.type is "INTOP":
      self.matchAndConsume("INTOP")
      self.parseExpr()
    else:
      print("intexpr epsilon")
    self.tree.returnToParent()
      
  def parseStringExpr(self):
    print("Parsing StringExpr() ...")
    self.tree.addNode("String", "branch")
    self.matchAndConsume('QUOTE')
    self.parseCharList()
    self.matchAndConsume('QUOTE')
    self.tree.returnToParent()
    
  def parseBooleanExpr(self):
    print("Parsing BooleanExpr() ...")
    self.tree.addNode("BooleanExpr", "branch")
    if self.currentToken.type is "L_PAREN":
      self.matchAndConsume("L_PAREN")
      self.parseExpr()
      self.matchAndConsume(self.terminals["BOOLOP"])
      self.parseExpr()
      self.matchAndConsume(")")
    else:
      self.matchAndConsume(self.terminals["B_VAL"])
    self.tree.returnToParent()
  
  def parseId(self):
    print("Parsing Id...")
    self.tree.addNode("Id", "branch")
    self.matchAndConsume(self.terminals["CHAR"])
    self.tree.returnToParent()
    
  def parseCharList(self):
    print("Parsing CharList() ...")
    self.tree.addNode("CharList", "branch")
    if self.currentToken.type is "CHAR":
      self.matchAndConsume(self.terminals["CHAR"])
      self.parseCharList()
    elif self.currentToken.type is "SPACE":
      self.matchAndConsume(self.terminals["SPACE"])
      self.parseCharList()
    else:
      # epsilon production
      print("charlist epsilon")
    self.tree.returnToParent()