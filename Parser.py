# Alexis Dionne
# Compiler Project 2 - Parser
# 3/6/19

from Token import Token
from Tree import Tree

class Parser:

  # the parser will determine if the program makes sense with the grammar
  
  def __init__(self, tokenList=[]):
    self.tokenList = tokenList  # the list of tokens generated by Lex
    self.currentToken = None    # the token we are currently trying to match
    self.nextToken = None       # one token look ahead
    self.tree = Tree()
    self.errors = 0
    
    self.FIRST = {
      "OfStatement" : ['P_STMT', 'CHAR', 'TYPE', 'W_STMT', 'I_STMT', 'L_BRACE'],
      "OfBooleanExpr" : ['L_BRACE', 'B_VAL']
    }
    self.terminals = {
      "CHAR" : ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],
      "DIGIT" : ['0','1','2','3','4','5','6','7','8','9'],
      "TYPE" : ['int', 'string', 'boolean'],
      "SPACE" : [' '],
      "BOOLOP" : ['==', '!='],
      "B_VAL" : ['false', 'true'],
      "INTOP" : ['+']
    
  def matchAndConsume(expectedTokens):
    if self.currentToken in expectedTokens:
      self.tree.addNode(self.currentToken.name, "leaf")
    else:
      # report an error because our next movement is bupkis
    
  def parseProgram():
    print("Parsing Program ...")
    self.tree.addNode("Program", "branch")
    parseBlock()
    matchAndConsume("$")
    
  def parseBlock():
    print("Parsing Block...")
    self.tree.addNode("Block", "branch")
    matchAndConsume("{")
    parseStatementList()
    matchAndConsume("}")
    self.tree.returnToParent()
    
  def parseStatementList():
print("Parsing Statement List...")
    self.tree.addNode("Statement List", "branch")
    if self.currentToken.type in self.FIRST["OfStatement"]:
      parseStatement()
      parseStatementList()
    else:
      # epsilon production - nothing happens
    self.tree.returnToParent()
  
  def parseStatement():
    print("Parsing Statement...")
    self.tree.addNode("Statement", "branch")
    if self.currentToken.type is 'P_STMT':
      parsePrint()
    elif self.currentToken.type is 'CHAR':
      parseAssignment()
    elif self.currentToken.type is 'TYPE':
      parseVarDecl()
    elif self.currentToken.type is 'W_STMT':
      parseWhile()
    elif self.currentToken.type is 'I_STMT':
      parseIf()
    elif self.currentToken.type is 'L_BRACE':
      parseBlock()
    self.tree.returnToParent()
      
  def parsePrint():
    print("Parsing Print...")
    self.tree.addNode("Print", "branch")
    matchAndConsume(firstOfPrint)
    matchAndConsume("(")
    parseExpr()
    matchAndConsume(")")
    self.tree.returnToParent()
  
  def parseAssignment():
    print("Parsing Assignment ...")
    self.tree.addNode("Assignment", "branch")
    parseId()
    matchAndConsume("=")
    parseExpr()
    self.tree.returnToParent()
  
  def parseVarDecl():
    print("Parsing VarDecl ...")
    self.tree.addNode("VarDecl", "branch")
    matchAndConsume("TYPE") # not the real thing, just a place holder
    parseId()
    self.tree.returnToParent()
  
  def parseWhile():
    print("Parsing While ...")
    self.tree.addNode("While", "branch")
    matchAndConsume(firstOfWhile)
    parseBooleanExpr()
    parseBlock()
    self.tree.returnToParent()
  
  def parseIf():
    print("Parsing If ...")
    self.tree.addNode("If", "branch")
    matchAndConsume(firstOfIf)
    parseBooleanExpr()
    parseBlock()
    self.tree.returnToParent()
    
  def parseExpr():
    print("Parsing Expr ...")
    self.tree.addNode("Expr", "branch")
    if self.currentToken.type is 'DIGIT':
      parseIntExpr()
    elif self.currentToken.type is 'QUOTE':
      parseStringExpr()
    elif self.currentToken.type in self.FIRST["OfBooleanExpr"]:
      parseBooleanExpr()
    elif self.currentToken.type is 'ID':
      parseId()
    self.tree.returnToParent()
      
  def parseIntExpr():
    print("Parsing IntExpr...")
    self.tree.addNode("IntExpr", "branch")
    matchAndConsume(firstOfDigit)
    if self.nextToken.type is "INTOP":
      matchAndConsume("+")
      parseExpr()
    else:
      # just the digit is consumed
    self.tree.returnToParent()
      
  def parseStringExpr():
    print("Parsing StringExpr ...")
    self.tree.addNode("String", "branch")
    matchAndConsume('"')
    parseCharList()
    matchAndConsume('"')
    self.tree.returnToParent()
    
  def parseBooleanExpr():
    print("Parsing BooleanExpr ...")
    self.tree.addNode("BooleanExpr", "branch")
    if self.currentToken.type is "L_PAREN":
      matchAndConsume("(")
      parseExpr()
      matchAndConsume(firstOfBoolop) # also a place holder
      parseExpr()
      matchAndConsume(")")
    else:
      matchAndConsume(firstOfBoolVal) # place holderrr
    self.tree.returnToParent()
  
  def parseId():
    print("Parsing Id...")
    self.tree.addNode("Id", "branch")
    matchAndConsume(firstOfChar)
    self.tree.returnToParent()
    
  def parseCharList():
    print("Parsing CharList ...")
    self.tree.addNode("CharList", "branch")
    if self.currentToken.type in firstOfChar:
      matchAndConsume(firstOfChar)
      parseCharList()
    elif self.currentToken.type is "SPACE":
      matchAndConsume(' ')
      parseCharList()
    else:
      # epsilon production
    self.tree.returnToParent()